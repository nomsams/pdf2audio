<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeReader v5.0 (Ultimate)</title>
    
    <!-- Core Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <!-- ONNX Runtime Web -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/browser-id3-writer@4.0.0/dist/browser-id3-writer.min.js"></script>

    <style>
        :root {
            --bg: #050505;
            --panel: #121212;
            --border: #2a2a2a;
            --accent: #6366f1;
            --accent-hover: #4f46e5;
            --text: #e5e5e5;
            --text-dim: #a3a3a3;
            --success: #22c55e;
            --error: #ef4444;
            --font: 'Segoe UI', system-ui, sans-serif;
        }

        * { box-sizing: border-box; outline: none; user-select: none; }
        
        body {
            font-family: var(--font); background: var(--bg); color: var(--text);
            margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden;
        }

        /* --- Header --- */
        header {
            height: 48px; background: var(--panel); border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between; padding: 0 16px;
        }
        .brand { font-weight: 700; font-size: 1rem; letter-spacing: -0.5px; color: var(--accent); }
        .toolbar { display: flex; gap: 8px; }

        /* --- Buttons & Inputs --- */
        button {
            background: #1f1f1f; color: var(--text); border: 1px solid var(--border);
            padding: 6px 12px; border-radius: 4px; font-size: 0.75rem; cursor: pointer;
            transition: 0.1s; font-weight: 500;
        }
        button:hover { background: #2d2d2d; border-color: #444; }
        button:active { transform: translateY(1px); }
        button.primary { background: var(--accent); border-color: var(--accent); color: #fff; }
        button.primary:hover { background: var(--accent-hover); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        input, select, textarea {
            background: #181818; border: 1px solid var(--border); color: var(--text);
            padding: 6px; border-radius: 4px; width: 100%; font-size: 0.75rem;
            font-family: var(--font); margin-bottom: 8px;
        }
        input:focus, select:focus, textarea:focus { border-color: var(--accent); }

        /* --- Layout --- */
        .workspace { display: flex; flex: 1; overflow: hidden; }
        
        .sidebar {
            width: 320px; background: var(--panel); border-right: 1px solid var(--border);
            display: flex; flex-direction: column; overflow-y: auto;
        }
        
        .main-area {
            flex: 1; background: #000; position: relative; display: flex; flex-direction: column;
        }

        /* --- Panels --- */
        .section { padding: 12px; border-bottom: 1px solid var(--border); }
        .section-title {
            font-size: 0.65rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--text-dim); font-weight: 700; margin-bottom: 8px;
            display: flex; justify-content: space-between; align-items: center;
        }

        /* --- Status --- */
        .status-box {
            background: #1a1a1a; border: 1px solid var(--border); border-radius: 4px;
            padding: 8px; font-size: 0.75rem; display: flex; align-items: center; gap: 8px;
        }
        .led { width: 8px; height: 8px; border-radius: 50%; background: #444; transition: 0.3s; }
        .led.on { background: var(--success); box-shadow: 0 0 8px var(--success); }
        .led.err { background: var(--error); box-shadow: 0 0 8px var(--error); }
        .led.busy { background: #eab308; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* --- Timeline --- */
        #timeline { flex: 1; overflow-y: auto; padding: 8px; }
        .t-item {
            background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
            padding: 8px; margin-bottom: 4px; font-size: 0.75rem;
            display: flex; justify-content: space-between; cursor: pointer;
        }
        .t-item:hover { border-color: #444; }

        /* --- PDF View --- */
        #pdf-wrapper { flex: 1; overflow-y: auto; padding: 40px; display: flex; flex-direction: column; align-items: center; }
        canvas { max-width: 100%; box-shadow: 0 0 40px rgba(0,0,0,0.5); border-radius: 2px; }
        #text-layer {
            margin-top: 20px; max-width: 800px; font-family: 'Georgia', serif;
            font-size: 1.1rem; line-height: 1.6; color: #d4d4d4; white-space: pre-wrap; user-select: text;
        }
        .highlight { background: rgba(99, 102, 241, 0.2); color: #fff; padding: 2px 0; }

        /* --- Logs --- */
        #logs {
            height: 120px; background: #080808; border-top: 1px solid var(--border);
            font-family: 'Consolas', monospace; font-size: 0.7rem; display: flex; flex-direction: column;
        }
        .log-bar {
            padding: 4px 8px; background: #111; border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; cursor: pointer;
        }
        .log-body { flex: 1; overflow-y: auto; padding: 8px; color: #0f0; }
        .l-row { margin-bottom: 2px; border-bottom: 1px solid #111; padding-bottom: 2px; }
        .l-err { color: #ff5555; }
        .l-warn { color: #fbbf24; }

        /* --- Footer --- */
        footer {
            height: 60px; background: var(--panel); border-top: 1px solid var(--border);
            display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; padding: 0 16px;
        }
        .controls { display: flex; gap: 16px; align-items: center; }
        .play-big {
            width: 40px; height: 40px; border-radius: 50%; background: var(--text); color: #000;
            border: none; display: flex; align-items: center; justify-content: center; font-size: 1.2rem;
        }
        .play-big:hover { background: #fff; transform: scale(1.05); }
        .play-big:disabled { background: #333; color: #555; transform: none; }

    </style>
</head>
<body>

<header>
    <div class="brand">VibeReader v5.0</div>
    <div class="toolbar">
        <button onclick="dom.fileImport.click()">üì• Import Project</button>
        <input type="file" id="fileImport" accept=".mp3" hidden>
        <button class="primary" onclick="dom.filePdf.click()">üìÑ Open PDF</button>
        <input type="file" id="filePdf" accept=".pdf" hidden>
    </div>
</header>

<div class="workspace">
    <div class="sidebar">
        <!-- 1. Engine Status -->
        <div class="section">
            <div class="section-title">Neural Engine</div>
            <div class="status-box">
                <div id="led" class="led busy"></div>
                <span id="status-msg">Initializing...</span>
            </div>
            <progress id="dl-bar" value="0" max="100" style="width:100%; height:4px; margin-top:8px; display:none;"></progress>
            
            <div id="manual-ui" style="display:none; margin-top:10px;">
                <button onclick="dom.fileManual.click()" style="width:100%; border-color:var(--error); color:var(--error);">
                    ‚ö†Ô∏è Manual Load (.onnx + .json)
                </button>
                <input type="file" id="fileManual" multiple accept=".onnx,.json" hidden>
            </div>
        </div>

        <!-- 2. AI Cleaning -->
        <div class="section">
            <div class="section-title">AI Text Cleaning</div>
            <select id="ai-provider" onchange="app.updateAiUI()">
                <option value="groq">Groq (Llama/Mixtral)</option>
                <option value="openai">OpenAI (GPT-4/3.5)</option>
            </select>
            <input type="password" id="ai-key" placeholder="API Key (gsk_... or sk-...)">
            
            <select id="ai-model">
                <!-- Populated by JS -->
            </select>
            
            <div style="display:flex; gap:5px; align-items:center; margin-bottom:8px;">
                <span style="font-size:0.65rem; color:var(--text-dim);">Temp:</span>
                <input type="range" id="ai-temp" min="0" max="2" step="0.1" value="0.1" style="flex:1;">
                <span id="temp-val" style="font-size:0.65rem;">0.1</span>
            </div>

            <textarea id="ai-prompt" rows="3" placeholder="System Prompt...">You are an expert OCR cleaner. Fix typos and artifacts. Output ONLY the cleaned text.</textarea>
        </div>

        <!-- 3. Voice & Timeline -->
        <div class="section">
            <div class="section-title">Voice</div>
            <select id="voice-sel"><option>Loading...</option></select>
            <div style="margin-top:5px; display:flex; align-items:center; gap:5px; font-size:0.75rem;">
                <input type="checkbox" id="auto-stitch" checked> <label for="auto-stitch">Auto-Stitch</label>
            </div>
        </div>

        <div class="section" style="flex:1; display:flex; flex-direction:column; border-bottom:none;">
            <div class="section-title">
                <span>Timeline</span>
                <span id="total-time">00:00</span>
            </div>
            <div id="timeline"></div>
            <button class="primary" style="width:100%; margin-top:8px;" onclick="app.export()">üíæ Export MP3</button>
        </div>
    </div>

    <div class="main-area">
        <div id="pdf-wrapper">
            <canvas id="pdf-canvas"></canvas>
            <div id="text-layer">Load a PDF to start.</div>
        </div>
    </div>
</div>

<div id="logs">
    <div class="log-bar" onclick="this.parentElement.style.height = this.parentElement.style.height==='25px'?'120px':'25px'">
        <span>System Logs</span>
        <span>‚Üï</span>
    </div>
    <div class="log-body" id="log-out"></div>
</div>

<footer>
    <div style="font-size:0.75rem; color:var(--text-dim);"><span id="play-status">Idle</span></div>
    <div class="controls">
        <button onclick="app.prev()">‚èÆ</button>
        <button id="btn-play" class="play-big" onclick="app.togglePlay()" disabled>‚ñ∂</button>
        <button onclick="app.next()">‚è≠</button>
    </div>
    <div style="font-size:0.75rem; color:var(--text-dim);">Kokoro 82M (Int8)</div>
</footer>

<script>
/**
 * ==========================================
 * VIBEREADER v5.0 - ROBUST CORE
 * ==========================================
 */

// 1. CONFIGURATION
const CONFIG = {
    // Direct Dropbox Link (Pre-resolved)
    modelUrl: "https://dl.dropboxusercontent.com/scl/fi/dro5xmkt2arvesxhj2a14/model_q8f16.onnx?rlkey=8v7d17jisunatozughonagimy&st=8jqup808&dl=1",
    voicesUrl: "https://dl.dropboxusercontent.com/scl/fi/v3ignh8iizgbo0qq2an53/voices.json?rlkey=k84pml5vd2oslwac56gpp4fj2&st=he7vmy4v&dl=1",
    dbName: "VibeReaderV5",
    storeName: "assets"
};

// 2. WASM PATH FIX (CRITICAL FOR "UNDEFINED" ERROR)
// This tells ONNX Runtime where to find the .wasm files on the CDN
ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/";

// PDF.js Worker
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';

// 3. DOM ELEMENTS
const dom = {
    led: document.getElementById('led'),
    status: document.getElementById('status-msg'),
    dlBar: document.getElementById('dl-bar'),
    manualUI: document.getElementById('manual-ui'),
    logOut: document.getElementById('log-out'),
    filePdf: document.getElementById('filePdf'),
    fileManual: document.getElementById('fileManual'),
    fileImport: document.getElementById('fileImport'),
    btnPlay: document.getElementById('btn-play'),
    voiceSel: document.getElementById('voice-sel'),
    timeline: document.getElementById('timeline'),
    textLayer: document.getElementById('text-layer'),
    canvas: document.getElementById('pdf-canvas'),
    aiProvider: document.getElementById('ai-provider'),
    aiModel: document.getElementById('ai-model'),
    aiKey: document.getElementById('ai-key'),
    aiTemp: document.getElementById('ai-temp'),
    tempVal: document.getElementById('temp-val')
};

// 4. LOGGER
const logger = {
    log: (msg) => logger.write(msg, '#0f0'),
    warn: (msg) => logger.write(msg, '#fbbf24'),
    error: (msg) => {
        logger.write(msg, '#ff5555');
        document.getElementById('logs').style.height = '120px'; // Auto expand
    },
    write: (msg, color) => {
        const div = document.createElement('div');
        div.className = 'l-row';
        div.style.color = color;
        div.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
        dom.logOut.appendChild(div);
        dom.logOut.scrollTop = dom.logOut.scrollHeight;
        console.log(msg);
    }
};

// 5. DATABASE
const db = {
    open: () => new Promise((resolve, reject) => {
        const r = indexedDB.open(CONFIG.dbName, 1);
        r.onupgradeneeded = (e) => {
            const d = e.target.result;
            if (!d.objectStoreNames.contains(CONFIG.storeName)) d.createObjectStore(CONFIG.storeName);
            if (!d.objectStoreNames.contains('timeline')) d.createObjectStore('timeline', { keyPath: 'id', autoIncrement: true });
        };
        r.onsuccess = () => resolve(r.result);
        r.onerror = (e) => reject(e.target.error);
    }),
    put: async (store, key, val) => {
        const d = await db.open();
        const tx = d.transaction(store, "readwrite");
        if(key) tx.objectStore(store).put(val, key);
        else tx.objectStore(store).put(val);
        return new Promise((r, j) => { tx.oncomplete = r; tx.onerror = j; });
    },
    get: async (store, key) => {
        const d = await db.open();
        const tx = d.transaction(store, "readonly");
        const req = tx.objectStore(store).get(key);
        return new Promise((r, j) => { req.onsuccess = () => r(req.result); req.onerror = j; });
    },
    getAll: async (store) => {
        const d = await db.open();
        const tx = d.transaction(store, "readonly");
        const req = tx.objectStore(store).getAll();
        return new Promise((r, j) => { req.onsuccess = () => r(req.result); req.onerror = j; });
    },
    clear: async (store) => {
        const d = await db.open();
        const tx = d.transaction(store, "readwrite");
        tx.objectStore(store).clear();
        return new Promise(r => tx.oncomplete = r);
    }
};

// 6. AI CLIENT (Groq & OpenAI)
class AiClient {
    constructor() {
        this.updateModels();
        dom.aiTemp.addEventListener('input', (e) => dom.tempVal.innerText = e.target.value);
        
        // Load saved key
        const savedKey = localStorage.getItem('vibe_ai_key');
        if(savedKey) dom.aiKey.value = savedKey;
        dom.aiKey.addEventListener('change', (e) => localStorage.setItem('vibe_ai_key', e.target.value));
    }

    updateModels() {
        const provider = dom.aiProvider.value;
        dom.aiModel.innerHTML = '';
        let models = [];
        if(provider === 'groq') {
            models = [
                {id: 'llama3-70b-8192', name: 'Llama 3 (70B)'},
                {id: 'llama3-8b-8192', name: 'Llama 3 (8B)'},
                {id: 'mixtral-8x7b-32768', name: 'Mixtral 8x7b'},
                {id: 'gemma-7b-it', name: 'Gemma 7B'}
            ];
        } else {
            models = [
                {id: 'gpt-4o', name: 'GPT-4o'},
                {id: 'gpt-4-turbo', name: 'GPT-4 Turbo'},
                {id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo'}
            ];
        }
        models.forEach(m => {
            const opt = document.createElement('option');
            opt.value = m.id; opt.innerText = m.name;
            dom.aiModel.appendChild(opt);
        });
    }

    async clean(text) {
        const key = dom.aiKey.value;
        if(!key) return text;

        const provider = dom.aiProvider.value;
        const model = dom.aiModel.value;
        const temp = parseFloat(dom.aiTemp.value);
        const sysPrompt = document.getElementById('ai-prompt').value;

        logger.log(`AI Cleaning via ${provider} (${model})...`);

        const messages = [
            {role: "system", content: sysPrompt},
            {role: "user", content: text}
        ];

        try {
            let url, headers, body;
            if(provider === 'groq') {
                url = "https://api.groq.com/openai/v1/chat/completions";
                headers = { "Authorization": `Bearer ${key}`, "Content-Type": "application/json" };
                body = JSON.stringify({ model, messages, temperature: temp });
            } else {
                url = "https://api.openai.com/v1/chat/completions";
                headers = { "Authorization": `Bearer ${key}`, "Content-Type": "application/json" };
                body = JSON.stringify({ model, messages, temperature: temp });
            }

            const resp = await fetch(url, { method: "POST", headers, body });
            if(!resp.ok) {
                const err = await resp.text();
                throw new Error(`API Error ${resp.status}: ${err}`);
            }
            const json = await resp.json();
            logger.log("AI Cleaning Success.");
            return json.choices[0].message.content;
        } catch(e) {
            logger.error(`AI Failed: ${e.message}`);
            return text; // Fallback to raw
        }
    }
}

// 7. AUDIO ENGINE
class AudioEngine {
    constructor() {
        this.session = null;
        this.voices = null;
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    }

    async init() {
        logger.log("Engine: Checking Cache...");
        try {
            // 1. Voices
            let vBlob = await db.get(CONFIG.storeName, 'voices.json');
            if(!vBlob) {
                logger.log("Engine: Downloading Voices...");
                dom.dlBar.style.display = 'block';
                vBlob = await this.download(CONFIG.voicesUrl);
                await db.put(CONFIG.storeName, 'voices.json', vBlob);
            }
            this.voices = JSON.parse(await vBlob.text());

            // 2. Model
            let mBlob = await db.get(CONFIG.storeName, 'model.onnx');
            if(!mBlob) {
                logger.log("Engine: Downloading Model...");
                dom.dlBar.style.display = 'block';
                mBlob = await this.download(CONFIG.modelUrl);
                await db.put(CONFIG.storeName, 'model.onnx', mBlob);
            }
            dom.dlBar.style.display = 'none';

            // 3. Compile
            logger.log("Engine: Compiling WASM (This may take a moment)...");
            dom.status.innerText = "Compiling...";
            
            const mBuffer = await mBlob.arrayBuffer();
            if(mBuffer.byteLength < 1000) throw new Error("Model file is too small (Corrupt download?)");

            this.session = await ort.InferenceSession.create(mBuffer, {
                executionProviders: ['wasm'], // Explicitly WASM
                graphOptimizationLevel: 'all'
            });

            logger.log("Engine: Ready!");
            dom.led.className = "led on";
            dom.status.innerText = "Ready";
            dom.btnPlay.disabled = false;
            dom.manualUI.style.display = 'none';
            
            this.populateVoices();
            return true;

        } catch(e) {
            logger.error(`Engine Init Failed: ${e.message || e}`);
            dom.led.className = "led err";
            dom.status.innerText = "Error";
            dom.manualUI.style.display = 'block';
            dom.dlBar.style.display = 'none';
            throw e;
        }
    }

    async download(url) {
        const resp = await fetch(url);
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const reader = resp.body.getReader();
        const total = +resp.headers.get('Content-Length');
        let loaded = 0;
        const chunks = [];
        while(true) {
            const {done, value} = await reader.read();
            if(done) break;
            chunks.push(value);
            loaded += value.length;
            if(total) dom.dlBar.value = (loaded/total)*100;
        }
        return new Blob(chunks);
    }

    populateVoices() {
        dom.voiceSel.innerHTML = '';
        Object.keys(this.voices).forEach(k => {
            if(k.match(/^[ab]/)) {
                const opt = document.createElement('option');
                opt.value = k; opt.innerText = k;
                if(k==='af') opt.selected = true;
                dom.voiceSel.appendChild(opt);
            }
        });
    }

    async generate(text, voice) {
        if(!this.session) throw new Error("Session not ready");
        
        // Tokenizer (Robust)
        const map = {
            ' ':0, '.':1, ',':2, '!':3, '?':4, "'":5, '-':6,
            'a':10, 'b':11, 'c':12, 'd':13, 'e':14, 'f':15, 'g':16, 'h':17, 'i':18, 'j':19,
            'k':20, 'l':21, 'm':22, 'n':23, 'o':24, 'p':25, 'q':26, 'r':27, 's':28, 't':29,
            'u':30, 'v':31, 'w':32, 'x':33, 'y':34, 'z':35
        };
        // Fallback: if char not in map, ignore or map to space
        const tokens = text.toLowerCase().split('').map(c => map[c] !== undefined ? map[c] : 0);
        const inputIds = new ort.Tensor('int64', BigInt64Array.from(tokens), [1, tokens.length]);
        const style = new ort.Tensor('float32', Float32Array.from(this.voices[voice]), [1, 256]);
        const speed = new ort.Tensor('float32', [1.0], [1]);

        const res = await this.session.run({ 'input_ids': inputIds, 'style': style, 'speed': speed });
        return res.audio.data;
    }

    play(data) {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        const buf = this.ctx.createBuffer(1, data.length, 24000);
        buf.getChannelData(0).set(data);
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        src.connect(this.ctx.destination);
        src.start();
        return new Promise(r => src.onended = r);
    }
}

// 8. APP LOGIC
class App {
    constructor() {
        this.engine = new AudioEngine();
        this.ai = new AiClient();
        this.state = { chunks: [], idx: 0, playing: false, pdfName: "Untitled" };
        
        // Event Listeners
        dom.filePdf.onchange = (e) => this.loadPdf(e.target.files[0]);
        dom.fileManual.onchange = (e) => this.manualLoad(e.target.files);
        dom.fileImport.onchange = (e) => this.importProj(e.target.files[0]);
        
        // Start
        this.engine.init();
        this.loadTimeline();
    }

    updateAiUI() { this.ai.updateModels(); }

    async manualLoad(files) {
        const fList = Array.from(files);
        const onnx = fList.find(f => f.name.toLowerCase().endsWith('.onnx'));
        const json = fList.find(f => f.name.toLowerCase().endsWith('.json'));
        
        if(onnx && json) {
            logger.log("Manual: Saving files...");
            await db.put(CONFIG.storeName, 'model.onnx', onnx);
            await db.put(CONFIG.storeName, 'voices.json', json);
            logger.log("Manual: Saved. Retrying Init...");
            this.engine.init();
        } else {
            alert("Select BOTH .onnx and .json files");
        }
    }

    async loadPdf(file) {
        if(!file) return;
        this.state.pdfName = file.name.replace('.pdf','');
        logger.log("PDF: Parsing...");
        
        const buf = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(buf).promise;
        const page = await pdf.getPage(1);
        
        const vp = page.getViewport({scale: 2.0});
        dom.canvas.width = vp.width; dom.canvas.height = vp.height;
        await page.render({canvasContext: dom.canvas.getContext('2d'), viewport: vp}).promise;

        logger.log("OCR: Running Tesseract...");
        const worker = await Tesseract.createWorker('eng');
        const { data: { text } } = await worker.recognize(dom.canvas);
        await worker.terminate();

        // AI Clean
        const cleanText = await this.ai.clean(text);
        
        this.state.chunks = cleanText.match(/[^.!?]+[.!?]+/g) || [cleanText];
        this.state.idx = 0;
        this.renderText();
        
        if(confirm("Clear previous timeline?")) {
            await db.clear('timeline');
            this.loadTimeline();
        }
    }

    renderText() {
        dom.textLayer.innerHTML = this.state.chunks.map((c, i) => 
            `<span id="c-${i}" class="${i===this.state.idx?'highlight':''}">${c}</span>`
        ).join(' ');
    }

    async togglePlay() {
        if(this.state.playing) {
            this.state.playing = false;
            dom.btnPlay.innerText = "‚ñ∂";
        } else {
            this.state.playing = true;
            dom.btnPlay.innerText = "‚è∏";
            this.loop();
        }
    }

    async loop() {
        if(!this.state.playing || this.state.idx >= this.state.chunks.length) {
            this.state.playing = false;
            dom.btnPlay.innerText = "‚ñ∂";
            return;
        }

        const txt = this.state.chunks[this.state.idx];
        this.renderText();
        document.getElementById(`c-${this.state.idx}`).scrollIntoView({block:'center', behavior:'smooth'});
        document.getElementById('play-status').innerText = "Generating...";

        try {
            const voice = dom.voiceSel.value;
            const audio = await this.engine.generate(txt, voice);
            
            if(document.getElementById('auto-stitch').checked) {
                this.addToTimeline(txt, audio);
            }

            document.getElementById('play-status').innerText = "Playing...";
            await this.engine.play(audio);
            
            if(this.state.playing) {
                this.state.idx++;
                this.loop();
            }
        } catch(e) {
            logger.error("Playback Error: " + e.message);
            this.state.playing = false;
        }
    }

    // Timeline & Export
    async addToTimeline(text, float32) {
        // Simple MP3 encode in main thread for simplicity in v5 (or use worker if preferred)
        // Using lamejs
        const mp3encoder = new lamejs.Mp3Encoder(1, 24000, 128);
        const samples = new Int16Array(float32.length);
        for(let i=0; i<float32.length; i++) {
            let s = Math.max(-1, Math.min(1, float32[i]));
            samples[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        const mp3Data = [];
        const blockSize = 1152;
        for(let i=0; i<samples.length; i+=blockSize) {
            const chunk = samples.subarray(i, i+blockSize);
            const buf = mp3encoder.encodeBuffer(chunk);
            if(buf.length > 0) mp3Data.push(buf);
        }
        const end = mp3encoder.flush();
        if(end.length > 0) mp3Data.push(end);
        
        const blob = new Blob(mp3Data, {type:'audio/mp3'});
        const item = { text: text.substring(0,20)+"...", blob, duration: float32.length/24000 };
        
        await db.put('timeline', undefined, item);
        this.loadTimeline();
    }

    async loadTimeline() {
        const items = await db.getAll('timeline');
        dom.timeline.innerHTML = '';
        let total = 0;
        items.forEach((it, i) => {
            total += it.duration;
            const div = document.createElement('div');
            div.className = 't-item';
            div.innerHTML = `<span>#${i+1} ${it.text}</span><span>${Math.round(it.duration)}s</span>`;
            dom.timeline.appendChild(div);
        });
        document.getElementById('total-time').innerText = `${Math.floor(total/60)}:${Math.floor(total%60).toString().padStart(2,'0')}`;
    }

    async export() {
        const items = await db.getAll('timeline');
        if(!items.length) return alert("Empty Timeline");
        
        const blobs = items.map(i => i.blob);
        const final = new Blob(blobs, {type:'audio/mp3'});
        const buf = await final.arrayBuffer();
        
        const writer = new ID3Writer(buf);
        writer.setFrame('TIT2', this.state.pdfName)
              .setFrame('COMM', {description:'VibeReaderData', text: JSON.stringify({
                  chunks: this.state.chunks,
                  idx: this.state.idx,
                  pdfName: this.state.pdfName
              })});
        writer.addTag();
        
        const url = URL.createObjectURL(writer.getBlob());
        const a = document.createElement('a');
        a.href = url; a.download = this.state.pdfName + ".mp3";
        a.click();
    }

    importProj(file) {
        if(!file) return;
        const r = new FileReader();
        r.onload = (e) => {
            const txt = new TextDecoder().decode(e.target.result.slice(0, 50000));
            const m = txt.match(/VibeReaderData.*?(\{.*\})/);
            if(m) {
                const d = JSON.parse(m[1]);
                this.state.chunks = d.chunks;
                this.state.idx = d.idx;
                this.state.pdfName = d.pdfName;
                this.renderText();
                alert("Project Loaded");
            } else alert("No Data Found");
        };
        r.readAsArrayBuffer(file);
    }

    next() { this.state.idx++; this.renderText(); }
    prev() { if(this.state.idx>0) this.state.idx--; this.renderText(); }
}

const app = new App();
</script>
</body>
</html>
